# définit le nom du workflow
name: Spring Back CI/CD

# liste les évènements déclenchant l'exécution du workflow
on:
  pull_request:
    branches: [main]
  push:
    branches: [dev]

# définition d'un job nommé "test-n-build" s'exécutant au sein d'un environnement
# dont l'OS est ubuntu dernière version
jobs:
  test-n-build:
    runs-on: ubuntu-latest

    # définit le répertoire actif par défault
    defaults:
      run:
        working-directory: "./back"

    steps:
      # ETAPE 1 : CHECKOUT
      # checks out le repository en utilisant l'action préexistante actions/checkout@v4
      # checkout : met le code du repository à disposition du workflow
      # i.e : cloning du repository, fetching du dernier commit, authentification git, ...
      - name: Check out repository code
        uses: actions/checkout@v4
        # with:
        # Shallow clones should be disabled for a better relevancy of analysis ???!!!
        # fetch-depth: 0

      # ETAPE 2 : INSTALLE & CONFIGURE ADOPTOPENJDK v17
      # installe & configure AdoptOpenJDK v17
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "adopt"

      # ETAPE 3 : BUILD LE BACKEND DE L’APPLICATION AVEC MAVEN
      # vide le repertoire /target de son contenu
      # compile le code java du projet
      # converti ce code en un jar, placé dans /target
      # copie le package Jar ou War dans le repository Maven local (~/.m2/repository)
      - name: Build with Maven
        # -DskipTests : permet à mvn clean install d'ignorer son comportement par
        # défault relatif à l'exécution des tests
        run: mvn clean install -DskipTests

      # ETAPE 4 : EXECUTE LES TESTS & GENERE LE COVERAGE
      # inutile d'exécuter mvn jacoco:report car le pom xml contient la génération du coverage
      # en tant que goal
      - name: Run Tests & Generate Jacoco Coverage
        run: mvn clean test

      # ETAPE 5 : GENERATION D’UN ARTEFACT CONTENANT CES DONNEES
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          # name: test-reports
          # résultats trouvés dans le repertoire suivant après génération
          # path: ./back/target/surefire-reports
          name: jacoco-coverage
          path: ./back/target/site/jacoco

      # ETAPE 6 : ANALYSE DE LA QUALITE DU CODE VIA SONARCLOUD
      # en utilisation la github action sonarsource/sonarcloud-github-action@master
      # préexistante
      - name: SonarCloud Back-end Scan
        uses: sonarsource/sonarcloud-github-action@master
        env:
          # token permettant au workflow de s'authentifier auprès de sonarcloud
          # généré via l'interface de sonarcloud & inséré en tant que secret
          # dans les settings du repository
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BACK }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
        with:
          # -Dsonar.java.binaries=./back/target/classes/com/openclassrooms/bobapp
          # projectKey : identifiant du projet qui regrupera les résultats de l'analyse
          # coverage.jacoco.xmlReportPaths : informations liées au coverage générées lors de l'étape
          # "Run Tests & Generate Jacoco Coverage"
          # exclusions : repertoires, sous repertoires, fichiers qui doivent être ignorés
          # lors de l'analyse
          # save : -Dsonar.exclusions=front/.angular/**,front/node_modules/**,front/coverage/**,front/src/environments/**,.git,.github,back/target/**,back/src/test/**,**/*.spec.ts,**/*.conf.js
          args: >
            -Dsonar.projectKey=ask0ldd_schoolwork-cicd-refresh-back
            -Dsonar.organization=ask0ldd
            -Dsonar.sources=./back/src/main/java
            -Dsonar.tests=./back/src/test/java
            -Dsonar.java.binaries=./back/target/classes
            -Dsonar.coverage.jacoco.xmlReportPaths=./back/target/site/jacoco/jacoco.xml
            -Dsonar.coverage.exclusions=front/.angular/**,front/node_modules/**,front/coverage/**,front/src/environments/**,.git,.github,back/target/**,back/src/test/**,**/*.spec.ts,**/*.conf.js
            -Dsonar.exclusions=front/.angular/**,front/node_modules/**,front/coverage/**,.git,.github,back/target/**

      # ETAPE 7 : AUTHENTIFICATION AUPRES DE DOCKER
      - name: Docker Login
        env:
          # utilisation des secrets générés via l'interface de docker
          # & insérés dans les settings du repository
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        run: |
          docker login -u $DOCKER_USERNAME -p $DOCKER_TOKEN

      # ETAPE 8 : BUILD & UPLOAD DE L’IMAGE DOCKER VERS DOCKERHUB
      - name: Build and Push Docker Image
        env:
          # utilisation d'un secret généré via l'interface de docker
          # & insérés dans les settings du repository
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          docker build -t $DOCKER_USERNAME/bobappback:latest .
          docker push $DOCKER_USERNAME/bobappback:latest
