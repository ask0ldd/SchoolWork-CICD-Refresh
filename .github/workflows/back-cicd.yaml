# définit le nom du workflow
name: Spring Back CI/CD

# liste les évènements déclenchant l'exécution du workflow
on:
  pull_request:
    branches: [main]
  push:
    branches: [dev]

# définition d'un job nommé "test-n-build" s'exécutant au sein d'un environnement
# dont l'OS est ubuntu dernière version
jobs:
  test-n-build:
    runs-on: ubuntu-latest

    # définit le répertoire actif par défault
    defaults:
      run:
        working-directory: "./back"

    steps:
      # ETAPE 1 : CHECKOUT
      # checks out le repository en utilisant l'action préexistante actions/checkout@v4
      # checkout : met le code du repository à disposition du workflow
      # i.e : cloning du repository, fetching du dernier commit, authentification git, ...
      - name: Check out repository code
        uses: actions/checkout@v4
        # with:
        # Shallow clones should be disabled for a better relevancy of analysis ???!!!
        # fetch-depth: 0

      # ETAPE 2 : INSTALLE & CONFIGURE ADOPTOPENJDK v17
      # installe & configure AdoptOpenJDK v17
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "adopt"

      # ETAPE 3 : BUILD LE BACKEND DE L’APPLICATION AVEC MAVEN
      # vide le repertoire /target de son contenu
      # compile le code java du projet
      # converti ce code en un jar, placé dans /target
      # copie le package Jar ou War dans le repository Maven local (~/.m2/repository)
      - name: Build with Maven
        # -DskipTests : permet à mvn clean install d'ignorer son comportement par
        # défault relatif à l'exécution des tests
        run: mvn clean install -DskipTests

      # ETAPE 4 : EXECUTE LES TESTS & GENERE LE COVERAGE
      # inutile d'exécuter mvn jacoco:report car le pom xml contient la génération du coverage
      # en tant que goal
      - name: Run Tests & Generate Jacoco Coverage
        run: mvn clean test

      # ETAPE 5 : GENERATION D’UN ARTEFACT CONTENANT CES DONNEES
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          # name: test-reports
          # résultats trouvés dans le repertoire suivant après génération
          # path: ./back/target/surefire-reports
          name: jacoco-coverage
          path: ./back/target/site/jacoco

      # ETAPE 6 : ANALYSE DE LA QUALITE DU CODE VIA SONARCLOUD
      # en utilisation la github action sonarsource/sonarcloud-github-action@master
      # préexistante
      - name: SonarCloud Back-end Scan
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BACK }}
        run: |
          mvn verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
            -Dsonar.projectKey=ask0ldd_schoolwork-cicd-refresh-back \
            -Dsonar.organization=ask0ldd \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.sources=src/main/java \
            -Dsonar.tests=src/test/java \
            -Dsonar.java.binaries=target/classes \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
            -Dsonar.coverage.exclusions=target/**,src/test/** \
            -Dsonar.exclusions=target/**

      #   - name: SonarCloud Quality Gate check
      #     uses: sonarsource/sonarcloud-github-action@master
      #     if: github.event_name == 'pull_request'
      #     env:
      #       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #       SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_BACK }}

      - name: Fetch PR comments
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          comments=$(gh api repos/${{ github.repository }}/issues/$PR_NUMBER/comments)
          echo "$comments" > sonar-reports.json

      - name: Upload comments as artifact
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: sonar-reports
          path: sonar-reports.json

      # ETAPE 7 : BUILD & UPLOAD DE L’IMAGE DOCKER VERS DOCKERHUB
      - name: Docker Image Build & Push to DockerHub
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        run: |
          docker login -u $DOCKER_USERNAME -p $DOCKER_TOKEN
          docker build -t $DOCKER_USERNAME/bobappback:latest .
          docker push $DOCKER_USERNAME/bobappback:latest
